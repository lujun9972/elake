#+TITLE: Readme
#+AUTHOR: DarkSun
#+CATEGORY: elake
#+DATE: [2015-07-10 周五 16:58]
#+OPTIONS: ^:{}

* elake简介
仿真rake的elisp实现

* 使用方法
类似make,elake中的任务也分为两种,phony任务与file任务. 其中file任务对应操作系统中的一个文件路径.

一个任务的依赖任务是否执行由以下表格表示:
| 目标任务类型 | 依赖任务类型 | 依赖任务执行条件                     |
|--------------+--------------+----------------------------------------------|
| phony任务 | phony任务  | 依赖任务未执行                        |
| file任务 | phony任务  | 依赖任务未执行                        |
| phony任务  | file任务   | 依赖任务对应的文件不存在         |
| file任务 | file任务 | 依赖任务对应的文件要比目标任务对应的文件更新 |

** 定义任务
定义任务的方法是使用宏 =(elake-task 目的任务 (依赖任务列表) 任务说明字符串 任务定义内容)=. 

例如我们这样定义一个做饭的过程:
#+BEGIN_SRC emacs-lisp :tangle elakefile.el
  (elake-task :purchaseVegetables nil
        "任务1 -- 买菜"
        (message  "到沃尔玛去买菜。"))

  (elake-task :cook (:purchaseVegetables)
      "任务2 -- 做饭"
      (message  "做一顿香喷喷的饭菜。"))
#+END_SRC

上面代码定义了两个任务

第一个任务的名称为":purchaseVegetables",它以":"开头,因此是一个phony任务.

+ :purchaseVegetables任务的依赖任务列表为nil,表示它不依赖任何前置任务

+ :purchaseVegetables任务的说明是"任务1 -- 买菜"

+ :purchaseVegetables任务的内容是 =(message  "到沃尔玛去买菜。")=

第二个任务的名称为":cook",它是一个phony任务. 它依赖于:purchaseVegetables任务.

因此,在执行:cook任务前会先执行:purchaseVegetables
#+BEGIN_EXAMPLE
  $ elake :cook
  到沃尔玛去买菜。
  做一顿香喷喷的饭菜。
#+END_EXAMPLE

** 自动变量
在任务定义中,可以使用$<指代目标任务,使用$@指代依赖任务列表. 例如:
#+BEGIN_SRC emacs-lisp :tangle elakefile.el
  (elake-task :task1 (/etc/passwd)
    "测试自动变量"
    (message "%s依赖于%s" $< $@))
#+END_SRC

执行任务:task1的结果为:
#+BEGIN_EXAMPLE
  $ elake :task1
  :task1依赖于(/etc/passwd)
#+END_EXAMPLE

** 默认构建任务
elake会将地一个定义的任务作为默认的构建任务. 当没有为elake指定构建哪个任务时,elake会构建默认的构建任务.

例如,上面的例子中,我们地一个定义的任务是:purchaseVegetables任务,因此直接调用elake的结果为:
#+BEGIN_EXAMPLE
  $ elake
  到沃尔玛去买菜。
#+END_EXAMPLE

** 命名空间
elake支持命名空间的概念. 使用命名空间的格式为 =(elake-namespace 命名空间名称 其他elake命令...)=

在命名空间内定义的phony任务,其完整的名称为":命名空间名称:任务名称",命名空间对file任务无效
例如:
#+BEGIN_SRC emacs-lisp :tangle elakefile.el
  (elake-namespace home
      (elake-task :write-blog (:turn-on-computer) ;注意,同一个命名空间内的依赖任务无需加命名空间前缀
        "写博客"
        (message  "在家写博客"))
    (elake-task :turn-on-computer ()
      "打开电脑"
      (message  "打开家里的电脑")))
#+END_SRC

这里在home命名空间内定义了两个任务:":home:write-bog和:home:turn-on-computer".
#+BEGIN_EXAMPLE
  $ elake :home:write-blog
  打开家里的电脑
  在家写博客
  $ elake :write-blog
  未定义的任务::write-blog
#+END_EXAMPLE

** 给任务传递环境变量值
给elake传递形如"环境变量:=值"的参数,可以设定环境变量的值
#+BEGIN_SRC emacs-lisp  :tangle elakefile.el
  (elake-task :set-env nil
    "设置环境变量"
    (message "UNKNOW-ENV:%s" (getenv "UNKNOW-ENV")))
#+END_SRC

若不传递环境变量,则有:
#+BEGIN_EXAMPLE
  $ elake :set-env
  UNKNOW-ENV:nil
#+END_EXAMPLE

若传递环境变量,则:
#+BEGIN_EXAMPLE
  $ elake :set-env UNKNOW-ENV:=whatever
  UNKNOW-ENV:whatever
#+END_EXAMPLE

** 给任务传递参数值
可以在定义任务时,使用未定义的变量. 只需要通过形如"变量=值"的形式传递变量值就好. 例如
#+BEGIN_SRC emacs-lisp  :tangle elakefile.el
  (elake-task :say-hello-to  nil
      "给任务传递参数"
      (message "hello to %s" who))
#+END_SRC

若不传递参数值,则会执行出错
#+BEGIN_EXAMPLE
  $ elake :say-hello-to
  Symbol's value as variable is void: who
#+END_EXAMPLE

若传递参数值,则
#+BEGIN_EXAMPLE
  $ elake  who=darksun :say-hello-to
  hello to darksun
#+END_EXAMPLE
* 待完成事项
+ [X] 增加file类型的任务
+ [X] 增加命名空间的支持
+ [X] 仿照make添加一些自动变量
+ [X] 仿照make将第一个定义的任务作为默认的构建任务
+ [ ] 如何支持emacs本身已经占有的那些option呢?
+ [ ] 如何区分传递符号和字符串給emacs --script呢?
+ [ ] 支持定义任务和定义依赖相分离
+ [ ] 支持分多次添加依赖关系,这样就能用程序自动添加依赖关系
+ [X] 支持模式规则来自动生成某类文件
+ [X] 支持使用-f指定依赖文件,默认为elakefile或elakefile.el或elakefile.elc
+ [X] 支持带参数的任务
+ [X] 支持命令行设置环境参数
+ [X] 提供删除已定义任务的机制

